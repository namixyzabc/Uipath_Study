
UiPathのセレクターは、UI要素（ボタン、入力フィールドなど）を正確に特定するための「住所」のようなものです。XML形式の文字列で記述され、ロボットが画面上のどこを操作すればよいかを指示します。安定した自動化を実現するためには、セレクターを正しく理解し、編集できるスキルが不可欠です。

ここでは、UiPath独自のセレクター記法を中心に、その仕組みと活用方法を網羅的に解説します。
1. セレクターの基本構造
セレクターは、<タグ 属性='値' /> という形式のノード（要素）が連なって構成されます。

<wnd app='chrome.exe' cls='Chrome_WidgetWin_1' title='UiPath - Google Chrome' />

<webctrl tag='INPUT' type='text' />

タグ: UI要素の種類を表します。
wnd: ウィンドウ
html: WebページのHTMLドキュメント全体
webctrl: Webページ上の要素（ボタン、リンクなど）
uia: UI Automationテクノロジーで認識される要素
属性: タグが持つ具体的な情報です。
app: アプリケーションの実行ファイル名（例: chrome.exe）
title: ウィンドウやページのタイトル
tag: HTMLタグの種類（例: INPUT, DIV, A）
aaname: Accessible Name。UI要素に付けられた名前で、多くの場合、画面に表示されているテキストです。最も信頼性が高い属性の一つです。
id, name: HTML要素が持つIDやName属性。これらも信頼性が高いです。

セレクターは階層構造になっており、左から右へ、親要素から子要素へとたどる形でUI要素を特定します。
2. UiPath独自のセレクター記法
UiPathでは、静的なセレクターだけでなく、動的に変化するUIに対応するための独自の記法が用意されています。
2.1. ワイルドカード
属性の値が毎回少しずつ変わる場合に使います。

*（アスタリスク）: 任意の数の文字に一致します。

例: 毎月ファイル名が変わる請求書ウィンドウを特定する。
元のセレクター: title='請求書_202304.pdf - Adobe Reader'
ワイルドカード使用: title='請求書*.pdf - Adobe Reader'
これにより、「請求書_202305.pdf」や「請求書_ABC.pdf」など、パターンに合うすべてのウィンドウに一致します。

?（クエスチョンマーク）: 任意の1文字に一致します。

例: 2桁の月番号が変わるファイルを特定する。
title='レポート_2023_??.xlsx'
これにより、「レポート_2023_01.xlsx」から「レポート_2023_12.xlsx」まで一致します。
2.2. 変数と引数の埋め込み
セレクター内に変数を埋め込むことで、実行時に指定した値に基づいて動的に要素を特定できます。これは非常に強力で、実践的な開発で頻繁に使用されます。

構文: {{変数名}}

使い方:

ワークフロー内で変数（例: customerName）を定義し、値を代入します。
セレクターエディターまたはプロパティパネルで、セレクターの文字列をダブルクォーテーションで囲み、動的にしたい部分を {{変数名}} に置き換えます。

実践例: 顧客名が表示されている行をクリックする。

顧客名を変数 customerName に格納します（例: customerName = "株式会社A"）。
セレクターを以下のように編集します。

"<webctrl aaname='{{customerName}}' tag='TD' />"

これにより、ロボットは実行時に変数 customerName の値（この場合は "株式会社A"）を持つテーブルセルをクリックします。
2.3. あいまいセレクター (Fuzzy Matching)
OCRで読み取ったテキストや、わずかに表記が揺れる可能性があるテキストを扱う場合に有効です。

構文:

matching:属性名='fuzzy'
fuzzylevel:属性名='類似度'

使い方:

matching:aaname='fuzzy' を追加すると、aaname 属性のあいまい検索が有効になります。
fuzzylevel:aaname='0.8' を追加すると、類似度が80%（0.8）以上であれば一致したと見なします。値は0から1の間で指定します。

実践例: OCRで「UiPath」を「UlPath」と誤認識した場合でも特定する。

<webctrl aaname='UiPath' matching:aaname='fuzzy' fuzzylevel:aaname='0.8' />
2.4. 正規表現 (Regex)
ワイルドカードよりも複雑なパターンマッチングを行いたい場合に使用します。

構文: matching:属性名='regex'

使い方:

matching:aaname='regex' を追加し、属性の値に正規表現パターンを記述します。

実践例: 「請求書」の後に8桁の数字が続く要素を特定する。

正規表現パターン: 請求書\d{8} （\dは数字、{8}は8回繰り返し）
セレクター:

<webctrl aaname='請求書\d{8}' matching:aaname='regex' tag='SPAN' />
2.5. インデックス (idx)
同じタグと属性を持つ要素が複数ある場合に、何番目の要素かを指定します。

構文: idx='番号' （番号は1から始まります）
例: ページ上に同じ「ダウンロード」ボタンが3つあり、2つ目をクリックしたい場合。

<webctrl aaname='ダウンロード' tag='BUTTON' idx='2' />

注意点: idxはUIの構造が少し変わるだけで変化しやすく、セレクターを不安定にする原因になります。できるだけ aaname や id など他のユニークな属性で特定し、idx の使用は最後の手段と考えるのがベストプラクティスです。
2.6. 中間階層の省略（子孫要素の検索）
セレクターの階層の間に、可変的な要素や不要な要素が存在する場合、それらを無視して子孫要素を直接検索できます。

構文: セレクターの先頭に * を追加するか、Find Descendants スコープを使用します。

UI Explorerで子孫要素を検索すると、セレクターの先頭が * ではなく <webctrl /> のようにタグのみで属性がないノードで表現されることがあります。これも中間階層の省略を意味します。

例:

<wnd ... /><ctrl id='main' /><ctrl id='child' />
上記セレクターで、mainとchildの間に時々別の要素が入る場合、以下のように記述すると、main の子孫（子、孫、ひ孫...）から child を探します。
Find Descendantsスコープで生成されるセレクター:

<wnd ... /><ctrl id='main' />

<webctrl id='child' />

※この場合、Find ChildrenアクティビティのScopeプロパティをFindDescendantsに設定します。
3. セレクターの種類
セレクターには大きく分けて2つの種類があります。

完全セレクター:
ウィンドウ情報（<wnd ... /> や <html ... />）から始まり、単独でUI要素を一意に特定できます。
[クリック]や[文字を入力]など、単体のアクティビティで使用されます。
部分セレクター:
ウィンドウ情報を含まず、コンテナーアクティビティ（[アタッチウィンドウ]や[アプリケーション/ブラウザーを使用]）内で使用されます。
コンテナーが特定したウィンドウ内での相対的な位置を示します。
利点: コンテナーのセレクターを一つ修正すれば、その中のアクティビティすべての対象ウィンドウを一括で変更できるため、保守性が高くなります。
4. セレクターを安定させるためのヒント
信頼性の高い属性を選ぶ: id, name, aaname など、開発者が意図して設定し、変更されにくい属性を優先的に使用します。css-selectorや、自動生成されたように見える長いidは避けます。
動的な部分を汎用化する: タイトルやテキストに日付やIDが含まれる場合は、ワイルドカード (*) や変数 ({{}}) を活用してセレクターが壊れないようにします。
アンカーベースを活用する: 操作したい要素自体に良いセレクターがない場合、その近くにあるラベルなどの安定した要素を「アンカー（目印）」として利用します。（[アンカーベース]アクティビティやUI Explorerのアンカー指定機能）
UI Explorerを使いこなす:
UIツリーを確認し、より安定した親要素や子要素がないか探します。
不要で不安定な属性のチェックを外し、セレクターをシンプルにします。
[検証] ボタンでセレクターが正しく要素を指すか、[ハイライト] ボタンで画面上のどこを指しているかを常に確認する癖をつけましょう。

セレクターは、UiPath開発における最も重要で、最も奥が深い要素の一つです。これらの記法とテクニックをマスターすることが、信頼性の高いロボットを作成するための鍵となります。


