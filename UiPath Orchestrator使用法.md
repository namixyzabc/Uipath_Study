## UiPath Orchestrator ガイド

### はじめに：UiPath Orchestratorとは - RPAの心臓部にして司令塔

UiPath Studioでロボット（オートメーションプロジェクト）を開発しただけでは、RPA（Robotic Process Automation）の真価を最大限に引き出すことはできません。開発したロボットを組織全体で効率的に実行し、管理し、統制するためのプラットフォーム、それが**UiPath Orchestrator**です。

Orchestratorをオーケストラの「指揮者」に例えると分かりやすいでしょう。Studioで育成された個々の優秀な演奏者（ロボット）たちを、指揮者であるOrchestratorが統率し、いつ、どこで、どの曲を、どのように演奏させるかを指示します。これにより、個々の演奏が組み合わさって壮大な交響曲（業務全体の自動化）が完成するのです。

**■ なぜOrchestratorが必要なのか？**

Studio単体でもロボットの開発と実行は可能ですが、それはあくまで個人のPC上で手動実行するレベルに留まります。企業レベルでRPAを展開するには、以下のような課題が生じます。

*   **野良ロボット問題:** 誰がどんなロボットを、いつ動かしているのか管理できなくなる。
*   **非効率な実行:** 複数のロボットを特定の時間に動かしたいが、手動で実行するのは手間がかかる。
*   **セキュリティリスク:** ログインIDやパスワードなどの機密情報をStudioのワークフロー内に直接書き込むのは危険。
*   **拡張性の限界:** ロボットの台数や処理件数が増えた場合に対応が難しい。
*   **効果測定の困難:** どのロボットがどれだけ貢献しているのか、ROI（投資対効果）が不明確。

Orchestratorは、これらの課題をすべて解決するための強力なソリューションです。

**■ Orchestratorがもたらす主要なメリット**

1.  **集中管理 (Centralized Management):** 全てのロボット、プロセス、ユーザー、ライセンスを単一のWebインターフェースから一元管理できます。
2.  **実行とスケジューリング (Deployment & Scheduling):** 開発したロボットをサーバーや仮想マシンに展開し、指定したスケジュール（例: 毎日午前9時）や特定の条件（例: 新しいデータがキューに追加された時）で自動実行させることが可能です。
3.  **監視とロギング (Monitoring & Logging):** 全てのロボットの実行状況やパフォーマンスをリアルタイムで監視し、詳細な実行ログを確認できます。エラー発生時にはアラートを通知し、迅速な対応を促します。
4.  **スケーラビリティ (Scalability):** ロボットの台数を必要に応じて柔軟に増減させ、ビジネスの成長や業務量の変動に合わせた拡張が容易になります。
5.  **ガバナンスとセキュリティ (Governance & Security):** ユーザーごとに厳密な権限管理を行い、誰が何をできるかを制御します。また、アセット機能により、IDやパスワードなどの機密情報を暗号化して安全に管理できます。
6.  **ワークロード管理 (Workload Management):** キュー機能を用いて大量の処理データを効率的に分散・処理させ、ロボットの稼働率を最大化します。
7.  **人間とロボットの協働 (Human-in-the-Loop):** Action Centerを介して、ロボットが判断できない例外処理や承認作業を人間にエスカレーションし、シームレスな協働作業を実現します。

**■ Automation Cloud (SaaS) vs オンプレミス版**

Orchestratorには、UiPathが提供するクラウドサービス版と、自社のサーバーにインストールするオンプレミス版の2種類があります。

*   **Automation Cloud:**
    *   **メリット:** サーバーの構築やメンテナンスが不要。常に最新の機能が利用できる。迅速に導入可能。
    *   **デメリット:** カスタマイズ性に制限がある場合がある。クラウド利用に関する社内規定の確認が必要。
    *   **推奨ユーザー:** 中小企業、迅速にRPAを始めたい企業、インフラ管理の負担を避けたい企業。

*   **On-Premises (オンプレミス):**
    *   **メリット:** 自社のインフラ内で完結するため、高度なセキュリティポリシーにも対応可能。柔軟なシステム連携やカスタマイズが可能。
    *   **デメリット:** サーバーの構築、運用、保守にコストと専門知識が必要。バージョンアップは手動で行う必要がある。
    *   **推奨ユーザー:** 大企業、金融機関、厳しいデータ管理ポリシーを持つ企業。

本ガイドでは、現在主流となりつつあり、誰もがすぐに試せる**Automation Cloud版のOrchestrator**をベースに解説を進めます。基本的な概念や操作はオンプレミス版とほぼ共通です。

---

### 第1章：Orchestratorを理解するためのコア概念

Orchestratorを使いこなすには、まずその構成要素である専門用語を理解する必要があります。ここでは、最も重要ないくつかの概念を解説します。

#### 1-1. テナント (Tenant)

Orchestrator内の完全に独立した作業領域です。会社内の部署やプロジェクトごとにテナントを分けることで、他のテナントのロボットやデータに干渉することなく、独立した環境でRPAを管理・運用できます。Automation Cloudでは、アカウント作成時にデフォルトのテナントが1つ作成されます。

#### 1-2. フォルダ (Folders)

テナント内をさらに細かく分割するための管理単位です。PCのフォルダと同じように、関連するプロセス、ジョブ、アセットなどをまとめて管理します。フォルダには**クラシック (Classic)**と**モダン (Modern)**の2種類があり、現在では機能が豊富で柔軟な**モダンフォルダが主流であり、強く推奨**されています。

*   **モダンフォルダの利点:**
    *   階層構造（サブフォルダ）を作成可能。
    *   ユーザー/グループ単位で柔軟な権限設定が可能。
    *   後述する「マシンテンプレート」との連携が前提。

#### 1-3. ユーザー (Users) と グループ (Groups)

Orchestratorにアクセスする個人アカウントが「ユーザー」です。複数のユーザーをまとめて管理するための単位が「グループ」です。ユーザーやグループに対して、後述する「ロール」を割り当てることで、アクセス権限を制御します。

#### 1-4. ロール (Roles) と 権限 (Permissions)

「ロール」は権限の集合体です。例えば、「開発者ロール」にはプロセスの作成や編集の権限を、「運用者ロール」にはジョブの実行や監視の権限を、といった形で定義します。Orchestratorには予めいくつかの標準ロール（Administrator, Automation Userなど）が用意されていますが、独自のカスタムロールを作成することも可能です。これにより、「誰が」「どのフォルダで」「何をできるか」を非常に細かく制御できます。

#### 1-5. マシン (Machines)

ロボットが実行される物理マシンや仮想マシン（PC、サーバー、VDIなど）をOrchestratorに登録するためのオブジェクトです。モダンフォルダでは、主に**マシンテンプレート (Machine Template)**を使用します。

*   **標準マシン (Standard Machine):**
    *   **旧来の方法。** 1台のマシンとOrchestrator上の1つのマシンオブジェクトが1対1で対応。
    *   ロボットを実行したいPCの名称と完全に一致させる必要がある。
    *   ユーザーが固定のPCで作業する場合などに使用。

*   **マシンテンプレート (Machine Template):**
    *   **モダンフォルダでの標準的な方法。** 複数のマシンから同じキーを使ってOrchestratorに接続できるテンプレート。
    *   ユーザーがどのPCからでも接続できるVDI環境や、非固定のPCで作業する場合に非常に便利。
    *   接続するPC名を意識する必要がなく、管理が大幅に簡素化される。

#### 1-6. ロボット (Robots)

UiPathの文脈では、「ロボット」という言葉は複数の意味で使われますが、Orchestratorにおいては主に「実行ライセンス」と「実行主体」の概念を指します。

*   **Attended Robot (アテンド型ロボット):**
    *   人間のユーザーがPC上で行う作業を支援・代行するロボット。
    *   人間の指示（例: UiPath Assistantから実行ボタンをクリック）によって起動される。
    *   フロントオフィス業務（例: 問い合わせ対応の補助）に適している。
    *   ライセンスはユーザーに紐づく。

*   **Unattended Robot (アンアテンド型ロボット):**
    *   人間が介在せず、サーバーや仮想マシン上でバックグラウンドで自律的に動作するロボット。
    *   Orchestratorのトリガー（スケジュールなど）によって自動的に起動される。
    *   バックオフィス業務（例: 夜間のデータ集計、請求書処理）に適している。
    *   ライセンスはマシン（ランタイム）に紐づく。

#### 1-7. パッケージ (Packages)

UiPath Studioで開発され、Orchestratorに公開（Publish）されたオートメーションプロジェクトのファイル（`.nupkg`形式）です。パッケージには、ワークフローファイル、設定、依存関係などがすべて含まれています。同じパッケージの複数のバージョンをOrchestrator上で管理できます。

#### 1-8. プロセス (Processes)

パッケージを特定のフォルダに展開し、実行可能な状態にしたものです。一つのパッケージから複数のプロセスを作成することも可能です（例えば、同じパッケージを開発フォルダと本番フォルダにそれぞれプロセスとして展開するなど）。プロセスを作成する際には、使用するパッケージのバージョンを指定します。

**【パッケージとプロセスの関係】**
*   **パッケージ:** オートメーションの「設計図」。
*   **プロセス:** 設計図を特定の場所（フォルダ）で実行できるように「具現化」したもの。

#### 1-9. ジョブ (Jobs)

プロセスを実際に実行する際のインスタンス（実行単位）です。Orchestratorから「プロセスAを実行せよ」という命令を出すと、一つの「ジョブ」が作成され、Unattendedロボットに割り当てられます。ジョブは、成功、失敗、停止中などのステータスを持ち、実行ログが記録されます。

#### 1-10. トリガー (Triggers)

ジョブを自動的に開始させるための「引き金」です。主に2つの種類があります。

*   **タイムトリガー (Time Trigger):**
    *   指定したスケジュール（例: 毎朝9時、毎週末、毎月末など）に基づいてジョブを開始します。
    *   定期的なバッチ処理などに使用されます。

*   **キュートリガー (Queue Trigger):**
    *   後述する「キュー」に新しいアイテムが追加されたり、一定数のアイテムが溜まったりしたことを検知してジョブを開始します。
    *   イベントドリブン（事象の発生をきっかけとする）な処理を実現します。

#### 1-11. アセット (Assets)

ロボットが使用する外部データ、特に設定値や機密情報を安全に保管・管理するための仕組みです。ワークフロー内に直接書き込むのではなく、アセットから値を取得することで、以下のメリットがあります。

*   **セキュリティ向上:** IDやパスワードを「資格情報 (Credential)」アセットとして保存すると、値は暗号化され、開発者や運用者も直接中身を見ることはできません。
*   **メンテナンス性向上:** 設定値（URL、ファイルパス、メールアドレスなど）をアセットにしておけば、値が変更された際にワークフローを修正・再パブリッシュする必要がなく、Orchestrator上でアセットの値を変更するだけで対応できます。
*   **環境ごとの設定:** 同じアセット名でも、フォルダごとに異なる値を設定できるため、開発環境と本番環境で接続先を簡単に切り替えることができます。

**アセットの種類:**
*   **Text:** 文字列
*   **Integer:** 整数
*   **Boolean:** True/False
*   **Credential:** ユーザー名とパスワードのペア

#### 1-12. キュー (Queues) と トランザクション (Transactions)

大量のデータを一つずつ処理する場合に非常に強力な機能です。キューは「処理待ちデータのリスト（行列）」と考えることができます。

*   **キュー (Queue):** 処理対象のアイテムを格納するコンテナ。
*   **トランザクションアイテム (Transaction Item):** キューに追加される個々の処理データ。各アイテムは「新規」「処理中」「成功」「失敗」といったステータスを持ちます。

**キューの一般的な利用パターン (Dispatcher & Performer):**
1.  **Dispatcher (ディスパッチャー) ロボット:**
    *   処理対象のリスト（Excelファイル、データベース、メールなど）を読み込み、一件ずつトランザクションアイテムとしてキューに追加する役割を担う。
2.  **Performer (パフォーマー) ロボット:**
    *   キューからトランザクションアイテムを一つずつ取り出し、実際の業務処理（例: システムへの入力）を行う。
    *   処理が成功すればステータスを「成功」に、失敗すれば「失敗」に更新する。
    *   複数のPerformerロボットを同時に動かすことで、並列処理による大幅な時間短縮が可能。

キューを利用することで、処理の進捗管理、優先度設定、失敗したアイテムの自動リトライ、SLA（Service Level Agreement）の設定など、高度なワークロード管理が実現します。

---

### 第2章：【ハンズオン】Orchestratorを使ってみよう

概念を理解したところで、実際にOrchestratorを操作してみましょう。ここでは、Automation Cloudアカウントを作成し、Studioで作成した簡単なロボットをOrchestratorから実行するまでの一連の流れを体験します。

#### 2-1. 事前準備：Automation Cloudアカウントの作成

1.  [UiPath Automation Cloud](https://cloud.uipath.com/) にアクセスします。
2.  GoogleアカウントやMicrosoftアカウント、またはメールアドレスでサインアップし、無料のCommunityライセンスでアカウントを作成します。
3.  組織名などを入力し、セットアップを完了させると、Automation Cloudのポータル画面が表示されます。左側のメニューに「Orchestrator」があることを確認してください。

#### 2-2. Step 1: OrchestratorとUiPath Assistant/Studioを接続する

ロボットを実行するPCとOrchestratorを接続します。ここでは最も推奨される**マシンテンプレート**を使用した方法を解説します。

1.  **Orchestratorでの設定:**
    *   Automation Cloudのポータルから「Orchestrator」を開きます。
    *   左側のメニューで、操作したい**テナント**（通常は "DefaultTenant"）が選択されていることを確認します。
    *   モダンフォルダ（例: "Default" フォルダ）を選択します。
    *   `[マシン]` > `[マシン テンプレート]` を選択し、右上の `[マシン テンプレートを追加]` ボタンをクリックします。
    *   **テンプレート名**を入力します（例: "MyMachineTemplate"）。
    *   **ランタイムライセンス**を割り当てます。Unattendedロボットを動かす場合は、Unattendedランタイムの数を1以上に設定します。
    *   `[プロビジョニング]` ボタンをクリックして作成します。
    *   作成されたマシンテンプレートの右側にある `[...]` をクリックし、`[クリップボードにコピー]` を選択します。この**マシンキー**は後で使います。

2.  **UiPath Assistantでの設定:**
    *   PCでUiPath Assistantを起動します。
    *   右上のユーザーアイコンをクリックし、`[環境設定]` を選択します。
    *   `[Orchestrator の設定]` タブを開きます。
    *   接続の種類で `[サービス URL]` を選択します。
    *   **サービスURL:** Automation CloudのURLを入力します（例: `https://cloud.uipath.com/あなたの組織名/あなたのテナント名/`）。このURLはブラウザのアドレスバーで確認できます。
    *   **マシンキー:** 先ほどOrchestratorでコピーしたマシンキーを貼り付けます。
    *   `[接続]` ボタンをクリックします。
    *   ステータスが「接続済み、ライセンス済み」となれば成功です。

これで、あなたのPCはOrchestratorの管理下に入りました。

#### 2-3. Step 2: プロセスを公開（パブリッシュ）し、プロセスを作成する

次に、Studioで作成したロボットをOrchestratorで実行できるようにします。

1.  **Studioでのパブリッシュ:**
    *   UiPath Studioで簡単なプロジェクトを作成します。例えば、「メッセージボックス」アクティビティを配置し、`"Orchestratorからこんにちは！"` と表示させるだけのプロジェクトで構いません。
    *   デザインリボンの `[パブリッシュ]` ボタンをクリックします。
    *   **パブリッシュ先**として `[Orchestrator テナント プロセス フィード]` が選択されていることを確認します。
    *   `[次へ]` を進み、最後に `[パブリッシュ]` をクリックします。
    *   「プロジェクトは正常にパブリッシュされました」と表示されれば完了です。

2.  **Orchestratorでのプロセス作成:**
    *   Orchestratorの画面に戻り、モダンフォルダ（例: "Default"）を選択します。
    *   `[オートメーション]` > `[プロセス]` を選択します。
    *   右上の `[追加]` ボタンをクリックします。
    *   **パッケージソース名:** 先ほどパブリッシュしたパッケージ名が表示されるはずです。選択します。
    *   **パッケージのバージョン:** 最新のバージョンが自動で選択されます。
    *   **エントリポイント:** Main.xaml が選択されていることを確認します。
    *   **表示名:** Orchestrator上で表示されるプロセス名を入力します（例: "HelloWorld_Process"）。
    *   `[作成]` をクリックします。

これで、パッケージがプロセスとしてフォルダ内に登録され、実行可能な状態になりました。

#### 2-4. Step 3: ジョブを手動で実行する

作成したプロセスを、Orchestratorから手動で実行（ジョブを開始）してみましょう。

1.  **Orchestratorから実行:**
    *   `[オートメーション]` > `[プロセス]` のリスト画面で、先ほど作成したプロセスの右側にある `[ジョブを開始]` ボタン（再生マーク）をクリックします。
    *   **実行ターゲット:** `[ユーザー]` タブを選択し、自分のユーザーアカウントを選択します。
    *   **マシン:** `[任意のユーザー]` を選択します。
    *   `[開始]` ボタンをクリックします。
    *   PCの画面右下にトースト通知が表示され、UiPath Assistantがロボットの実行を開始します。
    *   Studioで作成したメッセージボックスが表示されれば成功です。

2.  **ジョブの確認:**
    *   Orchestratorの `[オートメーション]` > `[ジョブ]` 画面に移動します。
    *   今実行したジョブがリストに表示され、ステータスが「成功」となっていることを確認できます。ジョブをクリックすると、実行時間や使用したロボット、ログなどの詳細情報を見ることができます。

#### 2-5. Step 4: ジョブをスケジュールで自動実行する（タイムトリガー）

最後に、このプロセスを毎日決まった時間に自動実行するように設定してみましょう。

1.  **トリガーの作成:**
    *   Orchestratorで、プロセスを作成したフォルダを選択します。
    *   `[オートメーション]` > `[トリガー]` を選択します。
    *   右上の `[新しいトリガーを追加]` ボタンをクリックし、`[タイムトリガー]` を選択します。
    *   **名前:** トリガーの名称を入力します（例: "Daily_HelloWorld_Trigger"）。
    *   **プロセス:** 先ほど作成したプロセス（"HelloWorld_Process"）を選択します。
    *   **実行ターゲット:** ジョブの実行方法を選択します。
        *   `[動的に割り当て]`: Unattendedロボットが利用可能な場合に、指定した回数だけジョブを実行します。
        *   `[特定のユーザー/マシン]`: 実行するユーザーやマシンを明示的に指定します。
    *   **タイムゾーン:** `(UTC+09:00) Osaka, Sapporo, Tokyo` を選択します。
    *   **実行頻度:** `[毎日]` を選択し、実行したい時刻（例: 10:00）を設定します。他にも、毎週、毎月、詳細（Cron式）など、柔軟なスケジュール設定が可能です。
    *   `[追加]` ボタンをクリックします。

これで設定は完了です。指定した時刻になると、Orchestratorは自動的にジョブを開始し、Unattendedロボットに処理を実行させます。（※Unattended実行には、PCがログイン状態である必要はありませんが、PCの電源が入っていてネットワークに接続されている必要があります。）

---

### 第3章：【実践】高度な機能を使いこなす

基本的な実行方法をマスターしたら、次はOrchestratorの真価を発揮させるためのアセットとキューの活用方法を学びましょう。

#### 3-1. アセットの活用：設定値と資格情報を安全に管理する

ここでは、ロボットがログインするシステムのIDとパスワードを、安全な「資格情報アセット」として管理する方法を実践します。

1.  **Orchestratorで資格情報アセットを作成する:**
    *   Orchestratorで、モダンフォルダを選択します。
    *   `[アセット]` を選択し、`[アセットを追加]` ボタンをクリックします。
    *   **アセット名:** `Cred_SystemA` のように、分かりやすい名前を付けます。
    *   **種類:** `[資格情報]` を選択します。
    *   **ユーザー名:** ログインIDを入力します。
    *   **パスワード:** パスワードを入力します。
    *   `[作成]` をクリックします。これで、暗号化された資格情報アセットが作成されました。

2.  **Studioでアセットを利用する:**
    *   Studioで新しいプロジェクトを開きます。
    *   `UiPath.System.Activities` パッケージがインストールされていることを確認します。
    *   アクティビティパネルから `[資格情報を取得 (Get Credential)]` アクティビティをシーケンスにドラッグ＆ドロップします。
    *   **プロパティパネルの設定:**
        *   `Orchestrator フォルダー パス`: アセットを作成したフォルダのパスを入力します（例: "Default"）。空欄の場合は現在のフォルダが対象になります。
        *   `アセット名`: `"Cred_SystemA"` と入力します。
        *   `ユーザー名` (出力): `Ctrl+K` を押して、`str_Username` という名前のString型変数を作成します。
        *   `パスワード` (出力): `Ctrl+K` を押して、`sec_Password` という名前のSecureString型変数を作成します。
    *   これで、ロボットは実行時にOrchestratorから安全にユーザー名とパスワードを取得できます。`sec_Password` は特殊なSecureString型であり、そのままでは中身を見たりログに出力したりできないため、セキュリティが保たれます。
    *   取得した資格情報を使うには、`[ブラウザーを開く]` や `[文字を入力 (Type Into)]` などのアクティビティのプロパティで、`str_Username` と `sec_Password` をそれぞれ指定します。

このようにアセットを使うことで、本番環境のパスワードを開発者に知らせることなく、ロボットに安全に利用させることが可能になります。

#### 3-2. キューの活用：大量データを効率的に処理する（REFrameworkの基礎）

100件の請求書データを処理するシナリオを例に、キューの基本的な使い方を解説します。

1.  **Orchestratorでキューを作成する:**
    *   Orchestratorで、モダンフォルダを選択します。
    *   `[キュー]` を選択し、`[キューを追加]` ボタンをクリックします。
    *   **名前:** `Invoices` のように、分かりやすい名前を付けます。
    *   **トランザクションの自動リトライ:** `[はい]` に設定すると、アプリケーション例外で失敗したトランザクションを自動で再実行してくれます。
    *   **最大リトライ回数:** 自動リトライの上限回数を設定します（例: 2）。
    *   `[追加]` をクリックしてキューを作成します。

2.  **Dispatcherロボットの作成（キューにデータを追加）:**
    *   Studioで新しいプロジェクトを作成します（例: "Invoice_Dispatcher"）。
    *   `[Excel アプリケーション スコープ]` と `[範囲を読み込み]` を使って、請求書データが記載されたExcelファイルを読み込み、DataTable型の変数（例: `dt_Invoices`）に格納します。
    *   `[繰り返し (各行)] (For Each Row in Data Table)]` アクティビティで、`dt_Invoices` の各行をループ処理します。
    *   ループの中で、`[キュー アイテムを追加 (Add Queue Item)]` アクティビティを配置します。
    *   **プロパティパネルの設定:**
        *   `キュー名`: `"Invoices"` と入力します。
        *   `Orchestrator フォルダー パス`: キューを作成したフォルダのパスを指定します。
        *   `アイテム情報`: `[コレクション]` をクリックし、各請求書データをキーと値のペアで追加します。
            *   `名前`: "InvoiceNumber", `値`: `row("請求書番号").ToString()`
            *   `名前`: "Amount", `値`: `row("金額").ToString()`
            *   `名前`: "DueDate", `値`: `row("支払期日").ToString()`
    *   このDispatcherロボットを実行すると、Excelの100行分のデータが、100個のトランザクションアイテムとしてOrchestratorの "Invoices" キューに追加されます。

3.  **Performerロボットの作成（キューからデータを処理）:**
    *   Studioで新しいプロジェクトを作成します（**Robotic Enterprise Framework (REFramework)** のテンプレートを使用することを強く推奨します）。REFrameworkは、トランザクション処理に最適化された堅牢なテンプレートです。
    *   **`GetTransactionData.xaml` の編集:**
        *   `[トランザクション アイテムを取得 (Get Transaction Item)]` アクティビティで、`QueueName` に `"Invoices"` を指定し、キューからアイテムを1つ取得します。
    *   **`Process.xaml` の編集:**
        *   引数 `in_TransactionItem` を使って、Dispatcherが設定した各データを取得します。
            *   `in_TransactionItem.SpecificContent("InvoiceNumber").ToString()`
            *   `in_TransactionItem.SpecificContent("Amount").ToString()`
        *   これらのデータを使って、基幹システムへの入力などの本来の業務処理を実装します。
    *   **`SetTransactionStatus.xaml` の編集:**
        *   `Process.xaml` が正常に完了すれば、REFrameworkは自動的に `[トランザクションのステータスを設定 (Set Transaction Status)]` アクティビティを呼び出し、ステータスを「成功」にします。
        *   処理中にエラーが発生した場合（ビジネス例外 or アプリケーション例外）、例外処理ブロックでステータスを「失敗」に設定します。
            *   **ビジネス例外 (Business Rule Exception):** 処理ルールに合わないデータ（例: 金額がマイナス）。リトライは不要。
            *   **アプリケーション例外 (Application Exception):** システムのフリーズや予期せぬエラー。リトライが有効。
    *   このPerformerプロセスをOrchestratorに登録し、複数のUnattendedロボットで同時に実行させれば、100件のデータを高速に並列処理できます。

キューを使えば、どのデータが処理済みで、どれが失敗したかが一目瞭然となり、障害からの復旧も容易になります。

---

### 第4章：管理と運用のための機能

RPAの導入が拡大するにつれて、管理と運用の重要性が増します。Orchestratorは、そのための強力な機能を提供します。

#### 4-1. モニタリング：ロボットとジョブの状態を監視する

*   **ダッシュボード:**
    *   フォルダのホーム画面には、ロボット、ジョブ、キューの状態を視覚的に把握できるダッシュボードが表示されます。エラー率や成功率、ロボットの稼働状況などを一目で確認できます。
*   **ジョブ画面 (`[オートメーション]` > `[ジョブ]`):**
    *   すべてのジョブの履歴と現在の状態（成功、失敗、実行中、ペンディングなど）を確認できます。
    *   失敗したジョブの `[...]` > `[ログを表示]` をクリックすると、Studioの出力パネルに表示されていたログがすべて記録されており、エラーの原因調査に不可欠です。
*   **ロボット画面 (`[監視]` > `[ロボット]`):**
    *   各ロボットの現在のステータス（利用可能、ビジー、未接続など）や、実行中のプロセスを確認できます。
*   **ログ画面 (`[ログ]`):**
    *   テナント内のすべてのロボットから送信されたログを一元的に表示・検索できます。ログレベル（Info, Warn, Errorなど）や期間でフィルタリングすることが可能です。

#### 4-2. ユーザーと権限の管理（モダンフォルダ）

組織の規模が大きくなるほど、厳密な権限管理が求められます。

1.  **ロールの定義:**
    *   `[テナント]` > `[ロールを管理]` で、組織の役割に応じたカスタムロールを作成します（例: "経理部運用担当者"）。
    *   そのロールに必要な権限（例: ジョブの表示と開始、アセットの表示のみ）を細かくチェックして割り当てます。
2.  **ユーザー/グループの招待:**
    *   `[テナント]` > `[アクセス権を管理]` で、ユーザーをメールアドレスで招待したり、Active Directoryグループを連携したりします。
3.  **フォルダへの割り当て:**
    *   `[フォルダ]` > `[設定]` > `[アクセス権を管理]` で、特定のユーザーやグループに、先ほど定義したロールを割り当てます。
    *   これにより、「経理部のユーザーは、経理フォルダ内のプロセスしか実行できない」といった統制を実現できます。

#### 4-3. パッケージとプロセスのバージョン管理

業務プロセスの変更に伴い、ロボットの修正は頻繁に発生します。

*   **パッケージバージョン:**
    *   Studioで修正版をパブリッシュすると、Orchestratorの `[テナント]` > `[パッケージ]` 画面に新しいバージョンが追加されます。過去のバージョンも保持されます。
*   **プロセスの更新:**
    *   `[オートメーション]` > `[プロセス]` 画面で、更新したいプロセスの `[...]` > `[編集]` をクリックします。
    *   パッケージのバージョンを最新のものに変更することで、次回から実行されるジョブは新しいバージョンのワークフローを使用します。
    *   問題が発生した場合は、すぐに以前の安定バージョンに切り戻すことも可能です。

#### 4-4. ライセンス管理

`[テナント]` > `[ライセンス]` 画面で、保有しているライセンスの総数と使用状況を確認できます。モダンフォルダ環境では、ライセンスは主に以下の方法で割り当てられます。

*   **Attendedライセンス:** `[テナント]` > `[アクセス権を管理]` で、ユーザーまたはグループのライセンス設定を編集し、Attendedライセンスを割り当てます。
*   **Unattendedライセンス:** `[フォルダ]` > `[マシン]` > `[マシン テンプレート]` を編集し、そのテンプレートにUnattendedランタイムを割り当てます。これにより、そのテンプレートキーを使って接続したマシンでUnattended実行が可能になります。

---

### 第5章：さらに進んだ機能とエコシステム

Orchestratorは、単なる実行管理ツールに留まらず、UiPathプラットフォームの他のサービスと連携することで、より高度な自動化を実現します。

#### 5-1. Action Center：人間とロボットの協働を実現する

ロボットによる完全自動化が難しい業務、例えば「請求書の内容に不明な点がある場合の経理担当者への確認依頼」や「稟議申請の承認」など、人間の判断や操作が必要なタスクを管理するハブです。

*   ロボットは `[フォーム タスクを作成]` アクティビティを使って、Action Centerにタスクを生成し、担当者に割り当てることができます。
*   担当者はWebブラウザからAction Centerにアクセスし、自分に割り当てられたタスクを確認、必要な情報を入力・承認すると、待機していたロボットがその後の処理を再開します。

#### 5-2. Orchestrator API：外部システムとの連携

Orchestratorは豊富なREST APIを提供しており、外部のアプリケーション（チャットボット、自社ポータル、BIツールなど）からOrchestratorを操作できます。

*   **ユースケースの例:**
    *   Microsoft Teamsのボットからコマンドを送り、特定のプロセスを開始させる。
    *   ServiceNowでインシデントが起票されたら、API経由で調査ロボットを起動する。
    *   BIツールでOrchestratorのジョブ実行データを取得し、独自のROIダッシュボードを作成する。

APIの利用には、認証やプログラミングの知識が必要ですが、自動化の範囲を無限に広げる可能性を秘めています。

#### 5-3. Test Suite：RPAテストを自動化する

開発したRPAワークフローや、対象のアプリケーション自体の品質を担保するためのテスト管理・実行機能です。

*   テストケースの作成、テストデータ管理、テストの自動実行、結果レポートの生成などをOrchestrator上で一元管理できます。
*   これにより、RPA開発のライフサイクル全体（CI/CD）を自動化し、品質の高いロボットを迅速に展開することが可能になります。

---

### 第6章：ベストプラクティスとトラブルシューティング

#### 6-1. ベストプラクティス

*   **命名規則の徹底:** フォルダ、プロセス、アセット、キューなど、すべてのオブジェクトに一貫した命名規則（例: `[部署]_[業務内容]_[オブジェクト種別]`）を適用することで、管理性が劇的に向上します。
*   **モダンフォルダの積極活用:** 階層管理と柔軟な権限設定の恩恵を受けるため、原則としてモダンフォルダを使用します。
*   **REFrameworkの活用:** トランザクションベースの処理には、必ずREFrameworkをベースに開発します。エラーハンドリングやリトライ、ロギングの仕組みが組み込まれており、堅牢なロボットを効率的に開発できます。
*   **詳細なログ出力:** `[ログメッセージ]` アクティビティを適切に配置し、「処理開始」「データ取得成功」「〇〇の処理でエラー」など、後から実行内容を追跡できるようなログを設計します。特にエラー発生時の原因究明に役立ちます。

#### 6-2. よくあるトラブルシューティング

*   **ロボットが「未接続」「応答なし」になる:**
    *   **原因:** UiPath RobotサービスがPCで実行されていない、ネットワーク接続の問題、マシンキーやURLが間違っている。
    *   **対策:** PCのサービス一覧（`services.msc`）で "UiPath Robot Service" が実行中か確認する。UiPath Assistantで接続設定を再確認する。ファイアウォールが通信をブロックしていないか確認する。

*   **ジョブが「ペンディング」のまま開始されない:**
    *   **原因:** 実行可能なロボット（ライセンスが割り当てられ、ステータスが "利用可能"）がいない。Unattendedロボットの場合、実行するマシンにログインセッションが存在し、競合している。
    *   **対策:** `[監視]` > `[ロボット]` で、利用可能なロボットがいるか確認する。マシンテンプレートのランタイム数を確認する。Unattended実行用のマシンからサインアウト（切断ではなく）する。

*   **資格情報アセットが取得できない:**
    *   **原因:** プロセスを実行しているロボット（ユーザー）に、アセットが格納されているフォルダへのアクセス権限、およびアセットの表示権限がない。
    *   **対策:** `[フォルダ]` > `[設定]` > `[アクセス権を管理]` を開き、対象のユーザーまたはユーザーが所属するグループに、適切なロール（アセットの表示権限を含む）が割り当てられているか確認する。

---

活発なUiPath Community Forumも積極的に活用し、常に最新の知識をキャッチアップしていくことをお勧めします。このガイドが、あなたのOrchestrator習得の旅の一助となれば幸いです。
