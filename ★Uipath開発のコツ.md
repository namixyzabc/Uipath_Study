
---

### I. 設計・アーキテクチャ編

堅牢でメンテナンス性の高いロボットは、優れた設計から生まれます。

1.  **REFrameworkの徹底活用**
    *   これは基本中の基本ですが、その真価を理解して使うことが重要です。
    *   **コツ:**
        *   **トランザクションベース:** 1つの処理単位（例: 1件の申請処理、1つのファイル処理）を「トランザクション」として捉えることで、エラー時のリトライや中断箇所の特定が容易になります。
        *   **設定ファイル(Config.xlsx)の活用:** URL、ファイルパス、セレクターの一部、待機時間、ビジネスロジックのフラグなどを全てConfigに集約します。これにより、環境変更や仕様変更にコードを触らず対応できます。
        *   **例外処理の分離:** `BusinessRuleException`（業務ルール上の例外）と`ApplicationException`（システムエラー）を明確に使い分けることで、エラー後の挙動（リトライするか、スキップするか、停止するか）を制御しやすくなります。

2.  **ワークフローのコンポーネント化（部品化）**
    *   巨大な`Main.xaml`は悪です。意味のある単位で積極的にワークフローを分割しましょう。
    *   **コツ:**
        *   **ログイン・ログアウト:** アプリケーションの起動とログイン、終了処理は必ず別の`xaml`に切り出します。
        *   **共通処理:** 複数の箇所で使う処理（例: 特定の形式でファイルを保存、特定のエラー処理）は部品化して`Invoke Workflow File`で呼び出します。
        *   **引数の命名規則:** `in_`, `out_`, `io_`のプレフィックスを徹底することで、データの流れが格段に分かりやすくなります。

3.  **命名規則の徹底**
    *   自分だけでなく、他の人が見ても理解できるコードを書くための第一歩です。
    *   **コツ:**
        *   **変数:** `str_UserName`, `int_Counter`, `dt_Data`, `bool_IsSuccess`のように型と内容がわかるプレフィックスを付けます。
        *   **ワークフローファイル:** `Login_SAP.xaml`, `Process_InvoiceData.xaml` のように、動詞や目的語を入れて処理内容がわかるようにします。
        *   **アクティビティ:** `Assign (Initialize Counter)`, `Click (Submit Button)` のように、表示名を変更して何をしているか明確にします。

### II. 開発効率化編

日々の開発作業をスピードアップさせるテクニックです。

1.  **ショートカットキーの習得**
    *   マウス操作を減らすだけで、開発速度は劇的に向上します。
    *   **絶対覚えるべきショートカット:**
        *   `Ctrl + D`: 選択したアクティビティをコメントアウト
        *   `Ctrl + E`: コメントアウトを解除
        *   `Ctrl + K`: 変数を作成（例: `Assign`アクティビティの「To」欄で）
        *   `Ctrl + M`: 選択したアクティビティを新しいワークフローとして抽出（コンポーネント化に便利）
        *   `Ctrl + Shift + T`: アクティビティを検索して追加 (`Universal Search`より高速)
        *   `Ctrl + J`: スニペットを呼び出し

2.  **スニペット(Snippets)の活用**
    *   よく使うアクティビティの組み合わせを登録しておけます。
    *   **コツ:**
        *   標準的な`Try Catch`の構造
        *   `Log Message`の開始・終了セット
        *   特定のアプリケーションに対する`Attach Window`と後続処理のセット
        *   などを登録しておくと、ドラッグ＆ドロップ数回分の手間を削減できます。

3.  **オブジェクトリポジトリ(Object Repository)の活用**
    *   UI要素（セレクターやスクリーンショット）を一元管理する機能です。
    *   **メリット:**
        *   **再利用性:** 同じボタンを複数のワークフローで使う場合、リポジトリからドラッグするだけで利用できます。
        *   **保守性:** アプリケーションのUI変更でセレクターが壊れた場合、リポジトリの該当要素を1つ修正するだけで、それを使っている全てのワークフローに修正が反映されます。大規模開発では必須です。

4.  **ワークフローアナライザー(Workflow Analyzer)のカスタマイズ**
    *   プロジェクトのコーディング規約を自動でチェックする機能です。
    *   **コツ:**
        *   デフォルトのルールに加え、組織独自の命名規則や、使用を禁止したいアクティビティ（例: `Delay`）などをカスタムルールとして追加します。
        *   これにより、チーム全体のコード品質を一定に保つことができます。

### III. 堅牢性・安定性向上編

「たまに失敗する」ロボットから脱却するためのテクニックです。

1.  **最強のセレクター戦略**
    *   セレクターはロボットの生命線です。
    *   **コツ:**
        *   **UI Explorerを使いこなす:** `aaname`や`title`などの不安定な属性に頼らず、`id`, `automationid`, `name`など、変わりにくい属性を優先的に使います。
        *   **動的セレクター:** `*`（任意文字列）や`?`（任意の一文字）のワイルドカードを使いこなします。（例: `title='Microsoft Excel - Report*.xlsx'`）
        *   **変数を埋め込む:** `"<webctrl aaname='" + row("Name").ToString() + "' tag='A' />"` のように、セレクター内に変数を埋め込むことで、ループ処理で動的に変化する要素を的確に捉えます。
        *   **Fuzzy Selector (あいまいセレクター):** `matching:aaname='fuzzy'` を使うと、少しのテキスト揺れを許容してくれます。
        *   **`Find Children`アクティビティ:** テーブルやリストなど、構造は同じだが中身が動的に変わる要素群を取得するのに非常に強力です。`For Each UI Element`と組み合わせて使います。
        *   **`Anchor Base`アクティビティ:** 「請求書番号」というラベルの隣のテキストボックス、のように、安定した要素（アンカー）を基準に目的の要素を探します。

2.  **「待つ」ことのプロになる**
    *   `Delay`（固定時間待機）は極力使わないのが鉄則です。
    *   **正しい待機方法:**
        *   **`Check App State`:** 最も推奨される方法。指定したUI要素が出現/消滅するまで待機し、出現した場合としなかった場合で処理を分岐できます。タイムアウトも設定可能です。
        *   **`Find Element` / `Element Exists`:** 要素が出現するまで待機する目的で使います。`ContinueOnError = True`と組み合わせて、存在チェックにも利用できます。
        *   **`Wait for Download`:** Community提供のパッケージですが、ブラウザでのファイルダウンロード完了を確実に待機するのに便利です。

3.  **高度なエラーハンドリング**
    *   `Try Catch`をただ置くだけでなく、戦略的に使います。
    *   **コツ:**
        *   **`Retry Scope`:** ネットワークの瞬断や、アプリケーションの一時的なハングアップなど、リトライすれば成功する可能性がある処理に使います。
        *   **`Finally`句の活用:** `Try`ブロック内でエラーが発生しようがしまいが、**必ず実行したい処理**（例: アプリケーションを閉じる、一時ファイルを削除する）を`Finally`句に記述します。
        *   **具体的な例外を指定:** `Catch`で`System.Exception`だけを補足するのではなく、`SelectorNotFoundException`、`ApplicationException`など、想定される具体的な例外を個別に`Catch`することで、エラーごとの最適な処理を記述できます。

### IV. デバッグ・テスト編

問題解決を迅速に行うためのテクニックです。

1.  **デバッグパネルのフル活用**
    *   **ローカル(Locals)パネル:** 現在のスコープ内の変数値を全て確認できます。
    *   **ウォッチ(Watch)パネル:** 特定の変数の値を常に追跡したい場合に追加します。複雑な式の評価結果もウォッチできます。
    *   **イミディエイト(Immediate)パネル:** **これが最強です。** デバッグで一時停止中に、`dt_Data.Rows.Count`のように式を打ち込んで結果を確認したり、`int_Counter = 10`のように変数の値を強制的に書き換えて、特定の条件を再現したりできます。

2.  **戦略的なロギング**
    *   「処理開始」「処理終了」だけでなく、「何を」「なぜ」そうしたかを記録します。
    *   **コツ:**
        *   **トランザクション単位でログ:** 「Transaction X を開始」「Transaction X のデータ取得成功」「Transaction X の処理分岐: Aパターン」のように、トランザクションIDを含めてログを出力します。
        *   **重要な変数の値:** 分岐の条件となる変数の値や、処理結果をログに出力します。
        *   **ログレベルの使い分け:** `Info`, `Warn`, `Error`, `Trace`を適切に使い分け、Orchestratorでフィルタリングしやすくします。

3.  **高度なブレークポイント**
    *   ただ停止するだけではありません。
    *   **コツ:**
        *   **条件付きブレークポイント:** `counter > 100` のような条件式を設定し、特定の条件が満たされたときだけ停止させます。長いループのデバッグに絶大の効果を発揮します。
        *   **ログポイント:** ブレークポイントの設定で「Log Message」を選択すると、プログラムを停止させずに指定したメッセージをコンソールに出力できます。変数の中身を追跡したいが、処理は止めくない場合に便利です。

### V. その他・高度なテクニック編

より洗練されたコードを書くためのTIPSです。

1.  **LINQの活用**
    *   `DataTable`の操作に革命をもたらします。For Eachループを多用した複雑な処理を、1行のコードでスマートに記述できます。
    *   **よく使う例:**
        *   **フィルタリング:** `dt_Data.AsEnumerable().Where(function(row) row("Status").ToString = "Success").CopyToDataTable()`
        *   **特定列の合計:** `dt_Data.AsEnumerable().Sum(function(row) CInt(row("Amount")))`
        *   **重複削除:** `dt_Data.AsEnumerable().Distinct(DataRowComparer.Default).CopyToDataTable()`
    *   `Assign`アクティビティや`Invoke Code`で使います。最初は難しく感じるかもしれませんが、習得すれば生産性が飛躍的に向上します。

2.  **`Invoke Code`の使いどころ**
    *   標準アクティビティで実現が難しい、または煩雑になる処理に使います。
    *   **例:** 複雑な文字列操作、日付計算、API連携の細かな制御、LINQを使った高度なデータ操作など。
    *   何でもかんでも`Invoke Code`にすると可読性が下がるため、使いどころを見極めるのが重要です。

3.  **バックグラウンド実行の意識**
    *   プロジェクト作成時に「バックグラウンドプロセス」として作成すると、UI操作を伴わない（例: API連携、Excel・ファイル操作、メール送受信）プロセスを、ユーザーがPCを操作している裏で実行できます。
    *   開発時から`Click`や`Type Into`のようなUI操作系アクティビティを使わないように意識することで、実行効率の高いロボットになります。

---
